import { CheckBox, GroupBox, VerticalBox, HorizontalBox, SpinBox, TextEdit, Button, Spinner } from "std-widgets.slint";
import "./assets/fonts/JetBrainsMono-Regular.ttf";
import "./assets/fonts/JetBrainsMono-Bold.ttf";
import "./assets/fonts/JetBrainsMono-LightItalic.ttf";

enum FanMode {
    Normal,
    Eco,
    Power,
    Turbo,
    Unsupported,
}

struct Monitor {
    fan_mode: FanMode,
    cpu_fan_speed: int,
    gpu_fan_speed: int,
    cpu_temp: int,
    gpu_temp: int,
    bat_threshold: int,
}

struct AppConfig {
    color: brush,
}

global Palette {
    out property <brush> rosewater: #f4dbd6;
    out property <brush> flamingo: #f0c6c6;
    out property <brush> pink: #f5bde6;
    out property <brush> mauve: #c6a0f6;
    out property <brush> red: #ed8796;
    out property <brush> maroon: #ee99a0;
    out property <brush> peach: #f5a97f;
    out property <brush> yellow: #eed49f;
    out property <brush> green: #a6da95;
    out property <brush> teal: #8bd5ca;
    out property <brush> sky: #91d7e3;
    out property <brush> sapphire: #7dc4e4;
    out property <brush> blue: #8aadf4;
    out property <brush> lavender: #b7bdf8;
    out property <brush> text: #cad3f5;
    out property <brush> subtext1: #b8c0e0;
    out property <brush> subtext0: #a5adcb;
    out property <brush> overlay2: #939ab7;
    out property <brush> overlay1: #8087a2;
    out property <brush> overlay0: #6e738d;
    out property <brush> surface2: #5b6078;
    out property <brush> surface1: #494d64;
    out property <brush> surface0: #363a4f;
    out property <brush> base: #24273a;
    out property <brush> mantle: #1e2030;
    out property <brush> crust: #181926;
}

export global State {
    in property <bool> show-loader;
    in-out property <string> threshold-value;
    in property <bool> blocked;

    in-out property <AppConfig> config: {
        color: Palette.peach,
    };

    callback threshold-change(string, KeyEvent);
    callback fan-mode-change(FanMode);
    callback do-backspace(string) -> string; // Ugly hack cause slint can't manipulate strings for now
    callback set-threshold(string);
    callback save-config(AppConfig);
}

component BaseText inherits Text {
    color: Palette.text;
    font-size: 16px;
}

component PropValue {
    in property <string> prop;
    in property <string> value;
    HorizontalLayout {
        alignment: space-between;
        BaseText {
            color: Palette.subtext0;
            text: prop + ":";
        }

        BaseText {
            text: value;
        }
    }
}

component Header inherits Text {
    color: State.config.color;
    font-size: 20px;
    font-italic: true;
    font-weight: 800;
    font-family: "JetBrains Mono";
}

component BaseButton {
    in property <string> text;
    in property <bool> disabled: false;
    callback clicked();

    Rectangle {
        border-radius: 8px;
        border-color: State.config.color;
        background: State.config.color;
        states [
            disabled when disabled: {
                opacity: 0.4;
                in {
                    animate opacity {
                        duration: 200ms;
                        easing: ease-out;
                    }
                }
                out {
                    animate opacity {
                        duration: 200ms;
                        easing: ease-out;
                    }
                }
            }
            hover when area.has-hover: {
                background: State.config.color.darker(0.08);
                in {
                    animate background {
                        duration: 200ms;
                        easing: ease-out;
                    }
                }
                out {
                    animate background {
                        duration: 200ms;
                        easing: ease-out;
                    }
                }
            }
        ]
        VerticalLayout {
            alignment: center;
            padding-top: 4px;
            padding-bottom: 4px;
            HorizontalLayout {
                alignment: center;
                padding-left: 8px;
                padding-right: 8px;
                Text {
                    text: root.text;
                    font-size: 16px;
                    color: white;
                }
            }
        }

        area := TouchArea {
            width: parent.width;
            height: parent.height;
            mouse-cursor: pointer;
            states [
                disabled when disabled: {
                    mouse-cursor: not-allowed;
                }
            ]
            clicked => {
                clicked()
            }
        }
    }
}

component BatThreshold {
    out property <string> threshold_val <=> State.threshold-value;
    in-out property <int> bat_threshold_monitor;

    VerticalLayout {
        spacing: 8px;
        HorizontalLayout {
            alignment: space-between;
            BaseText {
                color: Palette.subtext0;
                text: "Current value:";
                horizontal-stretch: 0;
            }

            VerticalLayout {
                padding: 0;
                spacing: 2px;
                alignment: center;
                bat_threshold_val := TextInput {
                    width: apply_button.width;
                    horizontal-stretch: 1.0;
                    font-size: 16px;
                    text: threshold_val;
                    horizontal-alignment: center;
                    input-type: number;
                    single-line: true;
                    read-only: false;
                    key-pressed(event) => {
                        if event.text == Key.Return {
                            if State.blocked {
                                return EventResult.accept;
                            }
                            State.set-threshold(threshold_val);
                            bat_threshold_monitor = threshold_val.to-float();
                            return EventResult.accept;
                        }
                        if event.text == Key.Backspace {
                            threshold_val = State.do-backspace(threshold_val);
                        }
                        State.threshold-change(threshold_val, event);
                        EventResult.accept
                    }
                }

                VerticalLayout {
                    spacing: -1px;
                    Rectangle {
                        border-width: 1px;
                        width: bat_threshold_val.width;
                        height: 1px;
                        background: Palette.subtext0;
                    }

                    HorizontalLayout {
                        alignment: center;
                        Rectangle {
                            border-width: 1px;
                            width: 0;
                            height: 1px;
                            background: State.config.color;
                            opacity: 1.0;
                            states [
                                focused when bat_threshold_val.has-focus: {
                                    width: bat_threshold_val.width;
                                    opacity: 1.0;
                                    in {
                                        animate width {
                                            duration: 600ms;
                                            easing: ease-out-quart;
                                        }
                                    }
                                    out {
                                        animate opacity {
                                            duration: 150ms;
                                            easing: ease-out;
                                        }
                                    }
                                }
                            ]
                        }
                    }
                }
            }
        }

        HorizontalLayout {
            alignment: end;
            apply_button := BaseButton {
                text: "Apply";
                disabled: threshold_val == bat_threshold_monitor;
                clicked => {
                    if State.blocked {
                        return;
                    }
                    State.set-threshold(threshold_val);
                    bat_threshold_monitor = threshold_val.to-float();
                }
            }
        }
    }
}

component ColorPicker {
    in property <brush> color;
    in property <bool> not-selectable: false;
    Rectangle {
        border-radius: 9999px;
        background: color;
        width: 16px;
        height: 16px;

        VerticalLayout {
            alignment: center;
            HorizontalLayout {
                alignment: center;
                Rectangle {
                    opacity: 0;
                    border-radius: 9999px;
                    background: color.darker(0.4);
                    width: 6px;
                    height: 6px;
                    states [
                        picked when color == State.config.color && !not-selectable: {
                            opacity: 1.0;
                        }
                    ]
                }
            }
        }

        TouchArea {
            mouse-cursor: not-selectable ? default : pointer;
            clicked => {
                State.config.color = color;
                State.save-config(State.config);
            }
        }
    }
}

component Settings {
    property <physical-length> color-spacing: 20px;
    property <bool> show-colors;
    fade_timer := Timer {
        interval: 150ms;
        running: false;
        triggered => {
            color_popup.visible = false;
            self.running = false;
        }
    }

    TouchArea {
        clicked => {
            if (show-colors) {
                show-colors = false;
                fade_timer.running = true;
            }
        }
    }

    color_popup := Rectangle {
        TouchArea { }

        x: 80px;
        y: 15px;
        width: 190px;
        height: 60px;
        opacity: 0;
        visible: false;
        border-radius: 8px;
        background: Palette.mantle;
        states [
            animate when show-colors: {
                opacity: 1;
                y: 25px;
                out {
                    animate opacity, y {
                        duration: 150ms;
                        easing: ease-out;
                    }
                }
                in {
                    animate opacity, y {
                        duration: 150ms;
                        easing: ease-out;
                    }
                }
            }
        ]
        VerticalLayout {
            alignment: center;
            spacing: color-spacing;

            HorizontalLayout {
                spacing: color-spacing;
                alignment: center;
                ColorPicker {
                    color: Palette.peach;
                }

                ColorPicker {
                    color: Palette.sapphire;
                }

                ColorPicker {
                    color: Palette.rosewater;
                }

                ColorPicker {
                    color: Palette.flamingo;
                }

                ColorPicker {
                    color: Palette.pink;
                }

                ColorPicker {
                    color: Palette.red;
                }

                ColorPicker {
                    color: Palette.teal;
                }
            }

            HorizontalLayout {
                spacing: color-spacing;
                alignment: center;

                ColorPicker {
                    color: Palette.blue;
                }

                ColorPicker {
                    color: Palette.green;
                }

                ColorPicker {
                    color: Palette.lavender;
                }

                ColorPicker {
                    color: Palette.mauve;
                }

                ColorPicker {
                    color: Palette.maroon;
                }

                ColorPicker {
                    color: Palette.yellow;
                }

                ColorPicker {
                    color: Palette.sky;
                }
            }
        }
    }

    VerticalLayout {
        alignment: start;
        HorizontalLayout {
            alignment: space-between;
            BaseText {
                vertical-alignment: top;
                color: Palette.subtext0;
                text: "Application color";
            }

            VerticalLayout {
                alignment: center;
                HorizontalLayout {
                    spacing: 16px;

                    ColorPicker {
                        color: State.config.color;
                        not-selectable: true;
                    }

                    Image {
                        source: @image-url("./assets/svg/angle-down.svg");
                        width: 16px;
                        height: 16px;
                        colorize: Palette.surface2;
                        states [
                            show-colors when show-colors: {
                                rotation-angle: 180deg;
                                colorize: Palette.text;
                                out {
                                    animate rotation-angle, colorize {
                                        duration: 150ms;
                                        easing: ease-out;
                                    }
                                }
                                in {
                                    animate rotation-angle, colorize {
                                        duration: 150ms;
                                        easing: ease-out;
                                    }
                                }
                            }
                        ]
                        TouchArea {
                            mouse-cursor: pointer;
                            clicked => {
                                // Turn off previous timer
                                fade_timer.running = false;
                                // if current is show-colors, then close popup
                                if (show-colors) {
                                    fade_timer.running = true;
                                // else make it visible
                                } else {
                                    color_popup.visible = true;
                                }
                                show-colors = !show-colors;
                            }
                        }
                    }
                }
            }
        }
    }
}

component RadioButton {
    callback clicked;
    in property <bool> checked;
    in property <string> name;
    area := TouchArea {
        mouse-cursor: pointer;
        clicked => {
            root.clicked();
        }
    }

    HorizontalBox {
        padding: 0;
        alignment: start;
        VerticalLayout {
            padding: 0;
            alignment: center;
            outer := Rectangle {
                width: 18px;
                height: 18px;
                border-width: 1px;
                border-radius: 100px;
                border-color: Palette.subtext0;
                states [
                    uncheked-hover when checked: {
                        border-color: Palette.text;
                        out {
                            animate border-color {
                                duration: 100ms;
                                easing: ease-out;
                            }
                        }
                        in {
                            animate border-color {
                                duration: 100ms;
                                easing: ease-out;
                            }
                        }
                    }
                ]
                inner := Rectangle {
                    background: State.config.color;
                    width: 10px;
                    height: 10px;
                    border-radius: 100px;
                    states [
                        uncheked-hover when checked: {
                            opacity: 1.0;
                            out {
                                animate opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                        uncheked-hover when area.has-hover: {
                            opacity: 0.5;
                            out {
                                animate opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                        unchecked when !root.checked && !area.has-hover: {
                            opacity: 0.0;
                            out {
                                animate opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                    ]
                }
            }
        }

        BaseText {
            text: root.name;
            vertical-alignment: center;
            color: Palette.subtext0;
            states [
                checked when checked: {
                    color: Palette.text;
                    out {
                        animate color {
                            duration: 100ms;
                            easing: ease-out;
                        }
                    }
                    in {
                        animate color {
                            duration: 100ms;
                            easing: ease-out;
                        }
                    }
                }
            ]
        }
    }
}

component Loader {
    Rectangle {
        width: 44px;
        height: 44px;
        border-radius: 9999px;
        background: @linear-gradient(animation-tick() / 1.25s * 360deg, State.config.color.with-alpha(0.2) 33%, State.config.color 100%);
    }

    Rectangle {
        width: 40px;
        height: 40px;
        border-radius: 9999px;
        background: Palette.base;
    }
}

export component App inherits Window {
    background: Palette.base;
    padding-top: 0;
    default-font-family: "JetBrains Mono";
    width: 25rem;
    height: 25rem;
    title: "GigaLinux";
    in-out property <Monitor> monitor;
    property <[string]> list-fan-modes: ["Normal", "Eco", "Power", "Turbo"];
    property <[image]> icons: [
        @image-url("./assets/svg/list-ul.svg"),
        @image-url("./assets/svg/fan.svg"),
        @image-url("./assets/svg/battery-full.svg"),
        @image-url("./assets/svg/gear.svg")
    ];
    property <int> tab_state;
    function fan-mode-to-string(fan_mode: FanMode) -> string {
        if fan_mode == FanMode.Normal {
            "Normal"
        } else if fan-mode == FanMode.Eco {
            "Eco"
        } else if fan_mode == FanMode.Power {
            "Power"
        } else if fan_mode == FanMode.Turbo {
            "Turbo"
        } else {
            "Unsupported"
        }
    }

    VerticalBox {
        padding-top: 0;
        if tab_state == 0: info := VerticalBox {
            vertical-stretch: 1.0;
            alignment: start;
            Header {
                text: "Machine state";
            }

            PropValue {
                prop: "Fan mode";
                value: fan-mode-to-string(monitor.fan-mode);
            }

            PropValue {
                prop: "CPU temp";
                value: monitor.cpu-temp;
            }

            PropValue {
                prop: "GPU temp";
                value: monitor.gpu-temp;
            }

            PropValue {
                prop: "Battery threshold";
                value: monitor.bat-threshold;
            }

            PropValue {
                prop: "CPU fan speed";
                value: monitor.cpu-fan-speed;
            }

            PropValue {
                prop: "GPU fan speed";
                value: monitor.gpu-fan-speed;
            }
        }
        if tab_state == 1: fan_mode := VerticalBox {
            vertical-stretch: 1.0;
            alignment: start;
            Header {
                text: "Fan mode";
            }

            for i in [FanMode.Normal, FanMode.Eco, FanMode.Power, FanMode.Turbo]: RadioButton {
                checked: monitor.fan-mode == i ? true : false;
                clicked => {
                    if monitor.fan-mode == i {
                        return;
                    }
                    if State.blocked {
                        return;
                    }
                    monitor.fan-mode = i;
                    State.fan-mode-change(i)
                }
                name: fan-mode-to-string(i);
            }
        }
        if tab_state == 2: VerticalBox {
            vertical-stretch: 1.0;
            alignment: start;
            Header {
                text: "Battery threshold";
            }

            bat_threshold := BatThreshold {
                bat_threshold_monitor: monitor.bat-threshold;
            }
        }

        if tab_state == 3: VerticalBox {
            vertical-stretch: 1.0;
            alignment: start;
            Header {
                text: "Settings";
            }

            Settings {
                height: 100%;
            }
        }
        HorizontalBox {
            vertical-stretch: 0.0;
            height: 32px;
            for i in 4: Rectangle {
                area := TouchArea {
                    mouse-cursor: pointer;
                    clicked => {
                        root.tab_state = i;
                    }
                }

                image := Image {
                    width: 20px;
                    height: 20px;
                    source: icons[i];
                    colorize: Palette.surface2;
                    states [
                        active when tab_state == i: {
                            colorize: State.config.color;
                            opacity: 1;
                            out {
                                animate colorize, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate colorize, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                        hovered when area.has-hover: {
                            colorize: State.config.color;
                            opacity: 0.5;
                            out {
                                animate colorize, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate colorize, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                    ]
                }

                Rectangle {
                    width: parent.width;
                    height: 3px;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    border-bottom-left-radius: 0;
                    border-bottom-right-radius: 0;
                    background: Palette.surface2;
                    y: parent.height + 10px;

                    states [
                        active when tab_state == i: {
                            background: State.config.color;
                            opacity: 1;
                            out {
                                animate background, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate background, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                        hovered when area.has-hover: {
                            background: State.config.color;
                            opacity: 0.5;
                            out {
                                animate background, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate background, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                    ]
                }

                Rectangle {
                    opacity: 0;
                    width: parent.width;
                    height: 4px;
                    border-top-left-radius: 4px;
                    border-top-right-radius: 4px;
                    border-bottom-left-radius: 0;
                    border-bottom-right-radius: 0;
                    background: Palette.surface2;
                    y: parent.height + 9px;

                    states [
                        active when tab_state == i: {
                            background: State.config.color;
                            opacity: 1;
                            out {
                                animate background, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                            in {
                                animate background, opacity {
                                    duration: 100ms;
                                    easing: ease-out;
                                }
                            }
                        }
                    ]
                }
            }
        }
    }

    if State.show-loader: Rectangle {
        x: 0;
        y: 0;
        width: root.width;
        height: root.height;
        background: Palette.base;
        opacity: 0.4;
        TouchArea { }

        Loader { }
    }
}
